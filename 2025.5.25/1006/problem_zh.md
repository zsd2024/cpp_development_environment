1. 关于图灵机下面的说法哪个是正确的：
{{ select(1) }}
- 图灵机是世界上最早的电子计算机。
- 由于大量使用磁带操作，图灵机运行速度很慢。
- 图灵机只是一个理论上的计算模型。
- 图灵机是英国人图灵发明的，在二战中为破译德军的密码发挥了重要作用。

2. 关于 BIOS 下面的说法哪个是正确的：
{{ select(2) }}
- BIOS 是计算机基本输入输出系统软件的简称。
- BIOS 里包含了键盘、鼠标、声卡、图形界面显器等常用输入输出设备的驱动程序。
- BIOS 一般由操作系统厂商来开发完成。
- BIOS 能提供各种文件拷贝、复制、删除以及目录维护等文件管理功能。

3. 已知大写字母 $\texttt A$ 的 ASCII 编码为 $65$（十进制），则大写字母 $\texttt J$ 的十六进制 ASCII 编码为：
{{ select(3) }}
- 48      
- 49   
- 50     
- 以上都不是

4. 在字长为 $16$ 位的系统环境下，一个 $16$ 位带符号整数的二进制补码为 $1111111111101101$。其对应的十进制整数应该是：
{{ select(4) }}
- 19     
- -19     
- 18      
- -18

5. 一个包含 $n$ 个分支结点（非叶结点）的非空满 $k$ 叉树，$k\geq 1$，它的叶结点数目为：
{{ select(5) }}
- $nk + 1$    
-  $nk-1$    
-  $(k+1)n-1$    
- $(k-1)n+1$

6. 表达式 $\texttt{a*(b+c)-d}$ 的后缀表达式是：
{{ select(6) }}
- $\texttt{abcd*+-}$    
-  $\texttt{abc+*d-}$    
-  $\texttt{abc*+d-}$    
-  $\texttt{-+*abcd}$

7. 最优前缀编码，也称 Huffman 编码。这种编码组合的特点是对于较频繁使用的元素给与较短的唯一编码，以提高通讯的效率。下面编码组合哪一组不是合法的前缀编码。
{{ select(7) }}
- $(00,01,10,11)$  
-  $(0,1,00,11)$  
-  $(0,10,110,111)$  
-  $(1,01,000,001)$

8. 快速排序平均情况和最坏情况下的算法时间复杂度分别为： 
{{ select(8) }}
- 平均情况 $O(n \log_2 n)$，最坏情况 $O(n^2)$
- 平均情况 $O(n)$，最坏情况 $O(n^2)$
- 平均情况 $O(n)$，最坏情况 $O(n\log_2 n)$     
- 平均情况 $O(\log_2 n)$， 最坏情况 $O(n^2)$

9. 下图给出了一个加权无向图，从顶点 $V_0$ 开始用 prim 算法求最小生成树。则依次加入最小生成树的顶点集合的顶点序列为：![](http://luogu-ipic.oss-cn-shanghai.aliyuncs.com/youti/15.png)

{{ select(9) }}
- $V_0, V_1, V_2, V_3, V_5, V_4$  
-  $V_0, V_1, V_5, V_4, V_3, V_3$  
-  $V_1, V_2, V_3, V_0, V_5, V_4$ 
-  $V_1, V_2, V_3, V_0, V_4, V_5$

10. 全国信息学奥林匹克的官方网站为参与信息学竞赛的老师同学们提供相关的信息和资源，请问全国信息学奥林匹克官方网站的网址是：
{{ select(10) }}
- http://www.noi.com/				
- http://www.noi.org/
- http://www.noi.cn/				
- http://www.xinxixue.com/

11. 关于 CPU 下面哪些说法是正确的：
{{ select(11) }}
- CPU 全称为中央处理器（或中央处理单元）。
- CPU 能直接运行机器语言。
- CPU 最早是由 Intel 公司发明的。
- 同样主频下，32 位的 CPU 比 16 位的 CPU 运行速度快一倍。

12. 关于计算机内存下面的说法哪些是正确的：
{{ select(12) }}
- 随机存储器（RAM）的意思是当程序运行时，每次具体分配给程序的内存位置是随机而不确定的。
- 一般的个人计算机在同一时刻只能存/取一个特定的内存单元。
- 计算机内存严格说来包括主存（memory）、高速缓存（cache）和寄存器（register）三个部分。
- 1MB内存通常是指1024*1024字节大小的内存。

13. 关于操作系统下面说法哪些是正确的：
{{ select(13) }}
- 多任务操作系统专用于多核心或多个 CPU 架构的计算机系统的管理。
- 在操作系统的管理下，一个完整的程序在运行过程中可以被部分存放在内存中。
- 分时系统让多个用户可以共享一台主机的运算能力，为保证每个用户都得到及时的响应通常会采用时间片轮转调度的策略。
- 为了方便上层应用程序的开发，操作系统都是免费开源的。

14. 关于计算机网络，下面的说法哪些是正确的：
{{ select(14) }}
- 网络协议之所以有很多层主要是由于新技术需要兼容过去老的实现方案。
- 新一代互联网使用的 IPv6 标准是 IPv5 标准的升级与补充。
- TCP/IP 是互联网的基础协议簇，包含有 TCP 和 IP 等网络与传输层的通讯协议。
- 互联网上每一台入网主机通常都需要使用一个唯一的 IP 地址，否则就必须注册一个固定的域名来标明其地址。

15. 关于 HTML 下面哪些说法是正确的：
{{ select(15) }}
- HTML 全称超文本标记语言，实现了文本、图形、声音乃至视频信息的统一编码。
- HTML 不单包含有网页内容信息的描述，同时也包含对网页格式信息的定义。
- 网页上的超链接只能指向外部的网络资源，本网站网页间的联系通过设置标签来实现。
- 点击网页上的超链接从本质上就是按照该链接所隐含的统一资源定位符（URL）请求网络资源或网络服务。

16. 若 $3$ 个顶点的无权图 $G$ 的邻接矩阵用数组存储为 $\{\{0,1,1\},\{1,0,1\},\{0,1,0\}\}$，假定在具体存储中顶点依次为: $v_1, v_2, v_3$。关于该图，下面的说法哪些是正确的：
{{ select(16) }}
- 该图是有向图。
- 该图是强连通的。
- 该图所有顶点的入度之和减所有顶点的出度之和等于 $1$。
- 从 $v_1$ 开始的深度优先遍历所经过的顶点序列与广度优先的顶点序列是相同的。

17. 在带尾指针（链表指针 `clist` 指向尾结点）的非空循环单链表中每个结点都以 `next` 字段的指针指向下一个节点。假定其中已经有 $2$ 个以上的结点。下面哪些说法是正确的：
{{ select(17) }}
- 如果 $p$ 指向一个待插入的新结点，在头部插入一个元素的语句序列为：`p->next = clist->next; clist->next = p;` 
- 如果 $p$ 指向一个待插入的新结点，在尾部插入一个元素的语句序列为：`p->next = clist；clist->next = p;`
- 在头部删除一个结点的语句序列为：`p = clist->next; clist->next = clist->next->next; delete p;` 
- 在尾部删除一个结点的语句序列为：`p = clist; clist = clist ->next; delete p;`

18. 散列表的地址区间为 $0\sim 10$，散列函数为 $H(K)=K \bmod 11$。采用开地址法的线性探查法处理冲突，并将关键字序列 $26,25,72,38,8,18,59$ 存储到散列表中，这些元素存入散列表的顺序并不确定。假定之前散列表为空，则元素 $59$ 存放在散列表中的可能地址有：
{{ select(18) }}
- 5
- 7
- 9
- 10

19. 排序算法是稳定的意思是关键码相同的记录排序前后相对位置不发生改变，下列哪些排序算法是稳定的：
{{ select(19) }}
- 插入排序     
- 基数排序     
- 归并排序     
- 冒泡排序

20. 在参加 NOI 系列竞赛过程中，下面哪些行为是被严格禁止的：
{{ select(20) }}
- 携带书写工具，手表和不具有通讯功能的电子词典进入赛场。
- 在联机测试中通过手工计算出可能的答案并在程序里直接输出答案来获取分数。
- 通过互联网搜索取得解题思路。
- 在提交的程序中启动多个进程以提高程序的执行效率。

21. 拓扑排序是指将有向无环图 $G$ 中的所有顶点排成一个线性序列，使得图中任意一对顶点 $u$ 和 $v$，若 $\text{<}u,v\text{>} \in E(G)$，则 $u$ 在线性序列中出现在 $v$ 之前，这样的线性序列成为拓扑序列。如下的有向无环图，对其顶点做拓扑排序，则所有可能的拓扑序列的个数为______  
![](http://luogu-ipic.oss-cn-shanghai.aliyuncs.com/youti/16.png)       。
{{ input(21) }}

22. 某个国家的钱币面值有 $1, 7, 7^2, 7^3$ 共计四种，如果要用现金付清 $10015$ 元的货物，假设买卖双方各种钱币的数量无限且允许找零，那么交易过程中至少需要流通_______张钱币。
{{ input(22) }}

23. ```
#include <iostream>
using namespace std;

int a,b;

int work(int a,int b){
	if (a%b)
		return work(b,a%b);
	return b;
}

int main(){
	cin >> a >> b;
	cout << work(a,b) << endl;
	return 0;
}
```
输入：123 321  
输出：_________  
{{ input(23) }}

24. ```
#include <iostream>
using namespace std;
int main()
{
	int a[4],b[4];
	int i,j,tmp;
	for (i=0;i<4;i++)
		cin >> b[i];
	for (i=0;i<4;i++)
	{
		a[i]=0;
		for (j=0;j<=i;j++)
		{
			a[i]+=b[j];
			b[a[i]%4]+=a[j];
		}
	}
	tmp=1;
	for (i=0;i<4;i++)
	{
		a[i]%=10;
		b[i]%=10;
		tmp*=a[i]+b[i];
	}
	cout << tmp << endl;
	return 0;
}
```
输入：2 3 5 7   
输出：_______________ 
{{ input(24) }}

25. ```
#include <iostream>
using namespace std;

const int maxn=50;
const int y=2009;
int main()
{
	int n,c[maxn][maxn],i,j,s=0;
	cin >> n;
	c[0][0]=1;
	for(i=1;i<=n;i++)
	{
		c[i][0]=1;
		for(j=1;j<i;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		c[i][i]=1;
	}
	for(i=0;i<=n;i++)
		s=(s+c[n][i])%y;
	cout << s << endl;
	return 0;
}
```
输入：17  
输出：         
{{ input(25) }}

26. ```
#include <iostream>
using namespace std;

int main()
{
	int n,m,i,j,p,k;
	int a[100],b[100];
	cin >> n >> m;
	a[0]=n;
	i=0;
	p=0;
	k=0;
	do
	{
		for (j=0;j<i;j++)
			if (a[i]==a[j])
			{
				p=1;
				k=j;
				break;
			}
		if (p)
			break;
		b[i]=a[i]/m;
		a[i+1]=a[i]%m*10;
		i++;
	}while (a[i]!=0);
	
	cout << b[0] << ".";
	for (j=1; j<k; j++)
		cout << b[j];
	if (p)
		cout << "(";
	for (j=k;j<i;j++)
		cout << b[j];
	if (p)
		cout << ")";
	cout << endl;
	return 0;
}
```
输入：5 13   
输出：_________   
{{ input(26) }}

27. （最大连续子段和）给出一个数列（元素个数不多于 $100$），数列元素均为负整数、正整数、$0$。请找出数列中的一个连续子数列，使得这个子数列中包含的所有元素之和最大，在和最大的前提下还要求该子数列包含的元素个数最多，并输出这个最大和以及该连续子数列中元素的个数。例如数列为 $4,-5,3,2,4$ 时，输出 $9$ 和 $3$；数列为 $1,2,3,-5,0,7,8$ 时，输出 $16$ 和 $7$。  
```cpp
#include <iostream>
using namespace std;

int a[101];
int n,i,ans,len,tmp,beg,end;
int main(){
	cin >> n;
	for (i=1;i<=n;i++)
		cin >> a[i];
	tmp=0;
	ans=0;
	len=0;
	beg=     ①     ;
	for (i=1;i<=n;i++){
		if (tmp+a[i]>ans){
			ans=tmp+a[i];
			len=i-beg;
		}
		else if (        ②         &&i-beg>len)
			len=i-beg;
		if (tmp+a[i]    ③     ){
			beg=     ④     ;
			tmp=0;
		}
		else
			   ⑤        ;
	}
	cout << ans << " " << len << endl;
	return 0;
}
```
{{ input(27) }}

{{ input(28) }}

{{ input(29) }}

{{ input(30) }}

{{ input(31) }}

28. （寻找等差数列）有一些长度相等的等差数列（数列中每个数都为 $0\sim 59$ 的整数），设长度均为 $L$，将等差数列中的所有数打乱顺序放在一起。现在给你这些打乱后的数，问原先，$L$ 最大可能为多大？先读入一个数 $n(1\leq n\leq60)$，再读入 $n$ 个数，代表打乱后的数。输出等差数列最大可能长度 $L$。
```
#include <iostream>
using namespace std;
int hash[60];
int n, x, ans, maxnum;
int work(int now) {
	int first, second, delta, i;
	int ok;
	while (      ①       && !hash[now])
		++now;
	if (now > maxnum)
		return 1;
	first = now;
	for (second = first; second <= maxnum; second++)
		if (hash[second]) {
			delta =       ②       ;  
			if (first + delta *    ③      > maxnum) 
				break;
			if (delta == 0)
				ok = (      ④      ); 
			else{
				ok = 1;
				for (i = 0; i < ans; i++)
					ok =     ⑤     && (hash[first+delta*i]); 
			}
			if (ok){
				for (i = 0; i < ans; i++)
					hash[first+delta*i]--;
				if (work(first)) 
					return 1;
				for (i = 0; i < ans; i++)
					hash[first+delta*i]++;
			}
		}
	return 0;
}
int main(){
	int i;
	memset(hash, 0, sizeof(hash));
	cin >> n;
	maxnum = 0;
	for (i = 0; i < n; i++){
		cin >> x;
		hash[x]++;
		if (x > maxnum)
			maxnum = x;
	}
	for (ans = n; ans >= 1; ans--)
		if ( n%ans==0 &&     ⑥     ) {
			cout << ans << endl;
			break;
		}
	return 0;
}
```
{{ input(32) }}

{{ input(33) }}

{{ input(34) }}

{{ input(35) }}

{{ input(36) }}

{{ input(37) }}

