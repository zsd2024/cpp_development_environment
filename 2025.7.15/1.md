### 信息学奥赛一本通·初赛篇 入门级CSP-J第14套初赛模拟试题
#### 一、单项选择题（共15题，每题2分，共计30分；每题有且仅有一个正确选项）
1. 下列数中最大的数为（ ）
{{ select(1) }}
-  $ (10010101)_2 $
-  $ (236)_8 $
-  $ (66)_{16} $
-  $ (142)_{10} $

2. 微型计算机的以下选项中，（ ）的存取速度最快。
{{ select(2) }}
-  内存储器
-  外存储器
-  高速缓存
-  寄存器

3. 表达式 $ (3+5)\times25-34/(7-5) $ 的后缀形式是（ ）
{{ select(3) }}
-  3 5 + 25 * 34 7 5 - /
-  3 5 25 34 7 5 + * - /
-  3 5 25 + * 34 7 5 - /
-  3 5 25 + * - 34 / 7 5

4. 定义一颗有根树的深度：根结点的深度为 0，其余结点的深度等于该结点的父亲结点的深度加 1。一颗深度为 9 的完全二叉树至少包含（ ）个结点。
{{ select(4) }}
-  511
-  512
-  1023
-  1024

5. 下列程序的时间复杂度是（ ）
```cpp
int m,n,s=0;
cin>>m>>n;
for(int i=0;i<m;i++)
    for(int j=1;j<=n;j*=2)
        s++;
```
{{ select(5) }}
-  $ O(m^2) $
-  $ O(n^2) $
-  $ O(m \times n) $
-  $ O(m \times \log n) $

6. 下列各排序法中，最坏情况下的时间复杂度最低的是（ ）
{{ select(6) }}
-  选择排序
-  快速排序
-  堆排序
-  冒泡排序

7. 已知二叉树的中序遍历为 $ \texttt{DECHFCABI} $，后序遍历为 $ \texttt{HGFEDCIBA} $，则该二叉树的前序遍历为（ ）
{{ select(7) }}
-  $ \texttt{ABCDEFCHI} $
-  $ \texttt{ACDEFHGBI} $
-  $ \texttt{ADCEFHBI} $
-  $ \texttt{ACDEFCHBI} $

8. 设栈S的初始状态为空，若干个元素 $a,b,c,d,e$ 依次入栈 $S$，出栈序列为 $b,d,a,e,c$，则栈 $S$ 的最小容量为（ ）
{{ select(8) }}
-  $2$
-  $3$
-  $4$
-  $5$

9. 小明想开个造纸飞机的公司，于是雇了 $5$ 个人。每位员工要制造 $100$ 架飞机，一张 A1 纸能折 $7$ 架飞机，一包 A1 纸中有 $4$ 张纸。小明把一包纸拆开分给员工，确保每人分到的纸张数相同，且尽可能少用原材料。小明至少要买（ ）包 A1 纸。
{{ select(9) }}
-  $16$
-  $17$
-  $18$
-  $19$

10. 田忌与齐王各出10匹马赛马，田忌的马速度值为 $[90,17,18,88,88,66,96,96,76,98]$，齐王的马速度值为 $[99,91,99,70,77,88,88,69,66,100]$。田忌安排马对抗齐王的马，最多能赢（ ）两黄金。
{{ select(10) }}
-  $60$
-  $70$
-  $80$
-  $90$

11. 设 $ W=true $，$ X=Y=false $，$ Z=true $，以下逻辑运算表达式值为真的是（ ）
{{ select(11) }}
-  $ (W \land X) \lor (Y \land Z \lor \lnot W) $
-  $ W \land (X \lor Y \lor \lnot Z) \lor \lnot Z $
-  $ (W \land X \lor Y) \land Z $
-  以上都不对

12. 汉诺塔问题中，A 柱上的盘子只能移到 B 柱，B 只能移到 C，C 只能移到 A。A 柱有 3 个盘子，将盘子移到 C 柱至少需要（ ）次移动。
{{ select(12) }}
-  $7$
-  $17$
-  $21$
-  $31$

13. 5 本不同的书重新摆放，使每本书都不在原来位置，有（ ）种摆法。
{{ select(13) }}
-  $40$
-  $42$
-  $44$
-  $46$

14. 字符串 $ \texttt{zhangnahz} $ 本质不同的子串个数为（ ）
{{ select(14) }}
-  $40$
-  $41$
-  $42$
-  $43$

15. 一棵无向树有 7 片树叶，3 个 3 度顶点，其余顶点均为 4 度，有（ ）个4度结点。
{{ select(15) }}
-  $1$
-  $2$
-  $3$
-  $4$

#### 二、阅读程序（程序输入不超过数组或字符串定义的范围；判断题正确填"√"，错误填"×"；除特殊说明外，判断题每题1.5分，选择题每题3分，共计40分）
1.
```cpp
#include<iostream>
using namespace std;
int main() {
    int a,b;
    scanf("%d%d",&a,&b);
    int anx=1;
    while(b) {
        if(b&1) anx=anx*a;
        a=a*a;
        b>>=1;
    }
    printf("%d\n",anx);
    return 0;
}
```

**判断题**
(1) 输入$ a=10 $，$ b=10 $，能够正确输出答案。（ ）
{{ select(16) }}
-  √
-  ×

(2) 第6行的$ anx=1 $改成$ anx=0 $不会影响最终结果。（ ）
{{ select(17) }}
-  √
-  ×

(3) 将第8行与第9行交换位置，不会影响最终结果。（ ）
{{ select(18) }}
-  √
-  ×

(4) 将第10行改成$ b/=2 $，不会影响最终结果。（ ）
{{ select(19) }}
-  √
-  ×

**选择题**
(5) 输入$ a=2 $，下列哪个数字最可能为该程序输出的结果？（ ）
{{ select(20) }}
-  14
-  15
-  16
-  17

(6) 输入$ a=9 $，$ b=9 $，输出结果为（ ）
{{ select(21) }}
-  387420489
-  387420191
-  388420489
-  377420489

2.
```cpp
#include <bits/stdc++.h>
using namespace std;
struct num { int a,b; };
int index, k;
struct num temp;
void fun(struct num s[], int n) {
    for(k=0; k<n-1; k++) {
        index = k;
        for(int j=k+1; j<n; j++)
            if(s[j].b < s[index].b) index=j;
        if(index!=k) {
            temp = s[index];
            s[index]=s[k];
            s[k]=temp;
        }
    }
}
int main() {
    int count,i,k,m,n,no;
    struct num s[100];
    cin>>n>>m>>k;
    for(i=0; i<n; i++) {
        s[i].a=i+1;
        s[i].b=0;
    }
    i=0;
    count=no=0;
    while(no<n) {
        if(s[i].b==0)
            count++;
        if(count==m) {
            no++;
            s[i].b=no;
            count=0;
        }
        i++;
        if(i==n)
            i=0;
    }
    fun(s,n);
    printf("%d:%d\n",s[k-1].b,s[k-1].a);
    return 0;
}
```

**判断题**
(1) 若输入为0 0 0，程序运行会出错。（ ）
{{ select(22) }}
-  √
-  ×

(2) 若输入为1 2 3，输出为3:1。（ ）
{{ select(23) }}
-  √
-  ×

(3) 把第11行的"index!=k"改为1，不会影响程序运行结果。（ ）
{{ select(24) }}
-  √
-  ×

(4) 去掉第37和38行，不会影响程序运行结果。（ ）
{{ select(25) }}
-  √
-  ×

**选择题**
(5) 程序运行时输入5 4 3，输出（ ）
{{ select(26) }}
-  3:5
-  2:3
-  1:2
-  4:1

(6) 程序运行时输入7 5 2，输出（ ）
{{ select(27) }}
-  1:5
-  6:1
-  2:3
-  2:4

3.
```cpp
#include<iostream>
using namespace std;
long long a[100010],b[100010], ans;
void mnm(int L,int R) {
    if(L==R) return;
    int mid=(L+R)>>1;
    mnm(L,mid);
    mnm(mid+1,R);
    int i=L,j=mid+1,k=L;
    while(i<=mid&&j<=R) {
        if(a[i]>a[j]) {
            ans+=j-k;
            b[k++]=a[j++];
        } else
            b[k++]=a[i++];
    }
    while(i<=mid) b[k++]=a[i++];
    while(j<=R) b[k++]=a[j++];
    for(i=L;i<=R;i++) a[i]=b[i];
}
int main() {
    int i,n;
    cin>>n;
    for(i=1;i<=n;i++)
        cin>>a[i];
    mnm(1,n);
    cout<<ans;
    return 0;
}
```

**判断题**
(1) 去掉第6行，程序运行结果相同。（ ）
{{ select(28) }}
-  √
-  ×

(2) 第21行与第22行交换，程序运行结果相同。（ ）
{{ select(29) }}
-  √
-  ×

(3) 第7行改为$ int mid=(L+R)/2 $，程序运行结果相同。（ ）
{{ select(30) }}
-  √
-  ×

(4) 该算法的原理是归并排序。（ ）
{{ select(31) }}
-  √
-  ×

**选择题**
(5) 该程序的时间复杂度为（ ）
{{ select(32) }}
-  $ O(n) $
-  $ O(n \log n) $
-  $ O(n^2) $
-  $ O(n \log^2 n) $

(6) 程序输入4 3 2 3 2，输出为（ ）
{{ select(33) }}
-  2
-  3
-  4
-  5

(7) 程序输入4 6 5 2 4，执行到32行时，数组a[]的数据为（ ）
{{ select(34) }}
-  6 5 2 4
-  6 5 4 2
-  2 4 6 5
-  2 4 5 6

#### 三、完善程序（单选题，每小题3分，共计30分）
1. 判断输入的n个整数是否构成等比数列
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int cur,q,i,n,pre;
    cin>>n;
    ①;
    ②;
    pre=cur;
    for(i=3;i<=n;i++) {
        cin>>cur;
        if(③) break;
        q=cur/pre;
        ④;
    }
    if(⑤)
        printf("Yes\n");
    else
        printf("No\n");
    return 0;
}
```

**补全选项**
(1) ①处应填（ ）
{{ select(35) }}
-  cin>>pre>>cur;
-  cin>>pre;
-  cin>>cur;
-  cin>>cur>>pre;

(2) ②处应填（ ）
{{ select(36) }}
-  q=1;
-  q=0;
-  q=cur/pre;
-  q=pre/cur;

(3) ③处应填（ ）
{{ select(37) }}
-  cur>pre
-  cur==pre*q
-  cur<pre
-  cur!=pre*q

(4) ④处应填（ ）
{{ select(38) }}
-  cur=pre;
-  cur=q;
-  pre=cur;
-  pre=q;

(5) ⑤处应填（ ）
{{ select(39) }}
-  i>n
-  i>=n
-  i<n
-  i<=n

2. 计算所有子区间的次大值之和
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN=100005;
struct T {
    int v,id;
};
T x[MAXN];
int pre[MAXN],nxt[MAXN];
int cmp(T t1,T t2) { return t1.v<t2.v; }
void del(int p) {
    int L=pre[p],R=nxt[p];
    nxt[L]=R;
    pre[R]=L;
}
int main() {
    int n,i;
    scanf("%d",&n);
    for(i=1;i<=n;i++) {
        scanf("%d",&x[i].v);
        x[i].id=i;
    }
    ①;
    for(i=1;i<=n;i++)
        nxt[i]=i+1;
    nxt[0]=1;
    pre[n+1]=n;
    LL ans=0;
    ②;
    for(i=1;i<=n;i++) {
        int L1=pre[x[i].id];
        int R1=nxt[x[i].id];
        int L2=pre[L1];
        int R2=nxt[R1];
        if(L2!=-1) ans+=③*i;
        if(R2!=-1) ans+=④*i;
        del(x[i].id);
    }
    printf("%lld",ans);
    return 0;
}
```

**补全选项**
(1) ①处应填（ ）
{{ select(40) }}
-  pre[0]=-1;
-  pre[0]=0;
-  pre[0]=i;
-  pre[0]=n;

(2) ②处应填（ ）
{{ select(41) }}
-  sort(x,x+n,cmp);
-  sort(x,x+n+1,cmp);
-  sort(x+1,x+n+1,cmp);
-  sort(x+1,x+n,cmp);

(3) ③处应填（ ）
{{ select(42) }}
-  (L1-L2)*(x[i].id-L1);
-  (L1-L2)*(R1-x[i].id);
-  (R1-L2)*(x[i].id-L1);
-  (R1-L2)*(R1-x[i].id);

(4) ④处应填（ ）
{{ select(43) }}
-  (R2-R1)*(R2-x[i].id);
-  (R2-L1)*(x[i].id-R1);
-  (R2-R1)*(x[i].id-R1);
-  (R2-L1)*(R2-x[i].id);

(5) ⑤处应填()。
{{ select(44) }}
- i
- L1
- x[i].id
- r1
